
<!DOCTYPE html>
<html lang="en" >

<head>

  <meta charset="UTF-8">
  <link rel="shortcut icon" type="image/x-icon" href="https://static.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico" />
  <link rel="mask-icon" type="" href="https://static.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111" />
  <title>CodePen - All Gone (No Escape II)</title>
  
  
  
  
      <style>
      body, html {
	touch-action: none;
	content-zooming: none;
	position: absolute;
	margin: 0;
	padding: 0;
	width: 100%;
	height: 100%;
	overflow: hidden;
}

canvas {
	position: absolute;
	display: block;
	width: 100%;
	height: 100%;
	background:#000;
	cursor: pointer;
}
img {visibility: hidden;}
    </style>

  <script>
  window.console = window.console || function(t) {};
  window.open = function(){ console.log("window.open is disabled."); };
  window.print   = function(){ console.log("window.print is disabled."); };
  window.alert   = function(){ console.log("window.alert is disabled."); };
  window.confirm = function(){ console.log("window.confirm is disabled."); };
  window.prompt  = function(){ console.log("window.prompt is disabled."); };
  window.Notification = function() { console.log("HTML5 notifications are disabled."); };
</script>

  
    <script>
    (function() {
      /*
      * Capture all errors for this pen
      **/
      window.onerror = function(/* message, file, line */) {
        return true;
      };

      /*
      * Capture and kill Web Audio and Speech
      */
      if (typeof (AudioContext) != "undefined" || typeof (webkitAudioContext) != "undefined") {
        AudioContext = function() {
          return false;
        };

        webkitAudioContext = function() {
          return false;
        };
      }

      if (typeof (mozAudioContext) != "undefined") {
        mozAudioContext = function() {
          return false;
        };
      }

      if ("speechSynthesis" in window) {
        window.speechSynthesis = {};
      }
      if ("speak" in speechSynthesis) {
        speechSynthesis.speak = function() {
          return false;
        };
      }

      // Kill the browser asking for access to the video cam or audio
      navigator.getUserMedia = function() {
      };
      navigator.mozGetUserMedia = function() {
      };
      navigator.webkitGetUserMedia = function() {
      };
      navigator.mediaDevices.getUserMedia = function() {
      };

      
      /**
      * Capture and kill animations after X number of seconds
      **/
      var __animationDuration = 4000;
      var __animationsTimedOut = false;
      var __animationRequests = [];
      var __requestAnimationFrame = false;
      var __cancelAnimationFrame = false;
      var x, i;

      var vendorsReqestAnimationFrame = [
        "requestAnimationFrame",
        "mozRequestAnimationFrame",
        "webkitRequestAnimationFrame"
      ];

      // find the browsers requestAnimationFrame and cancelAnimationFrame
      for (x = 0; x < vendorsReqestAnimationFrame.length; x++) {
        if (!__requestAnimationFrame) {
          __requestAnimationFrame = window[vendorsReqestAnimationFrame[x]
          ];
        }
      }

      __cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

      // Wrap the requestAnimationFrame so we can stop it in the future
      function __reqFrame(callback, element) {
        // after the timeout we no longer take requests
        var timerID;
        if (__animationsTimedOut) {
          return 0;
        } else {
          timerID = __requestAnimationFrame(callback, element);
          __animationRequests.push(timerID);

          return timerID;
        }
      }

      for (x = 0; x < vendorsReqestAnimationFrame.length; x++) {
        window[vendorsReqestAnimationFrame[x]] = __reqFrame;
      }

      // Cancel the animations after expiration
      setTimeout(function() {
        for (i = 0; i < __animationRequests.length; i++) {
          __cancelAnimationFrame(__animationRequests[i]);
        }

        var ss = window.document.createElement("style");
        ss.textContent = "*, *::before, *::after { animation-play-state: paused !important; }";
        var ref = window.document.getElementsByTagName("script")[0];
        ref.parentNode.insertBefore(ss, ref);

        __animationsTimedOut = true;
      }, __animationDuration, "push");

      /**
      * Capture setInterval and setTimeout to kill after X number of seconds
      **/
      window.setInterval = (function(oldSetInterval) {
        var registered = [];

        function f(a,b) {
          // check if the time has expired,
          // after __animationDuration expires don't take anymore setIntervals
          if (this.timedOut) {
            return 0;
          } else {
            return registered[ registered.length ] = oldSetInterval(a,b);
          }
        }

        f.clearAll = function() {
          var r;

          while (r = registered.pop()) {
            clearInterval( r );
          }

          this.timedOut = true;
        };

        f.timedOut = false;

        return f;
      }(window.setInterval));

      window.setTimeout = (function(oldSetTimeout) {
        var registered = [];

        // because some of our timeouts may time out afterwards
        // we want to make sure they know the secret sauce to still use
        // setTimeout after the time has expired, thats why we have a
        // third param
        function f(a, b, push) {
          // check if the time has expired,
          // after __animationDuration expires don't take anymore requests
          if (this.timedOut && typeof(push) == "undefined") {
            return 0;
          } else {
            // If push is there, never clear that interval
            // so never add it to the registry
            if (push) {
              return oldSetTimeout(a,b);
            } else {
              return registered[ registered.length ] = oldSetTimeout(a,b);
            }
          }
        }

        f.clearAll = function() {
          var r;

          while (r = registered.pop()) {
            clearTimeout( r );
          }

          this.timedOut = true;
        };

        f.timedOut = false;

        return f;
      }(window.setTimeout));

      setTimeout(function() {

        setTimeout.clearAll();
        setInterval.clearAll();

        // Stop Web Animations API
        // Idea from Gregor: https://github.com/CodePen/CodePen-Bug-Reporting-Only/issues/173#issuecomment-203443301
        // Status as of August 2016:
        //  Chrome = stops animations
        //  Safari = doesn't support anyway
        //  Firefox = doesn't stop them, but probably will someday? Doesn't error
        if (document.timeline && typeof document.timeline.getAnimations === "function") {
          document.timeline.getAnimations().map(function(animation) {
            animation.pause();
          });
        }
    
      }, __animationDuration, "push");

    }());
  </script>

  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>


</head>

<body translate="no"  onload="_l='t';">

  <canvas></canvas>
<img id="heightmap" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAAAAADRE4smAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE82lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE5LTAxLTA1VDEzOjU4OjU4KzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOS0wMS0wNVQxMzo1OToyMiswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0wMS0wNVQxMzo1OToyMiswMTowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YzYwOTJhZjctYzUzYS05NDRjLTgyNzItMGY2ZWE4ZjVhMDIwIiB4bXBNTTpEb2N1bWVudElE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" alt="">
    <script src="//static.codepen.io/assets/common/stopExecutionOnTimeout-de7e2ef6bfefd24b79a3f68b414b87b8db5b08439cac3f1012092b2290c719cd.js"></script>

  
  

    <script >
      "use strict";
{
	////////////////////////////////////////////////////////////////
	const canvas = {
		init() {
			this.elem = document.querySelector("canvas");
			const gl = this.elem.getContext("webgl", { alpha: false });
			const vertexShader = gl.createShader(gl.VERTEX_SHADER);
			const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(vertexShader,	`
				uniform mat4 camProj, camView;
				attribute vec3 aPosition, aNormal;
				varying vec3 vColor;
				const vec3 lightDir = vec3(0, 1, 1);
				const vec3 lightColor = vec3(0.4, 0.35, 0.3);
				void main(void) {
					mat3 camView3 = mat3(camView);
					vec3 normal = camView3 * aNormal;
					vec4 pos = camView * vec4(aPosition, 1.0);
					vColor = (lightColor * dot(normal, lightDir) + 0.2 * aPosition.y - 0.5);
					vColor = mix(vColor, camView3 * vec3(2.0 - 2.0 * pos.x, 0.3 * pos.z, 1.8 * pos.y), 0.03);
					gl_Position = camProj * pos; 
				}
			`
			);
			gl.shaderSource(fragmentShader,	`
				precision highp float;
				varying vec3 vColor;
				void main(void) {
					gl_FragColor = vec4(vColor, 1.0);
				}
			`
			);
			gl.compileShader(vertexShader);
			gl.compileShader(fragmentShader);
			this.program = gl.createProgram();
			gl.attachShader(this.program, vertexShader);
			gl.attachShader(this.program, fragmentShader);
			gl.linkProgram(this.program);
			gl.useProgram(this.program);
			return gl;
		},
		resize() {
			this.width = this.elem.width = this.elem.offsetWidth;
			this.height = this.elem.height = this.elem.offsetHeight;
			camera.proj.perspective(60, this.width / this.height).load();
			gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
		}
	};
	////////////////////////////////////////////////////////////////
	const Mat4 = class {
		constructor(program, uName) {
			this.u = gl.getUniformLocation(program, uName);
			this.data = new Float32Array([
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			]);
		}
		identity() {
			const d = this.data;
			d[0] = 1;
			d[1] = 0;
			d[2] = 0;
			d[3] = 0;
			d[4] = 0;
			d[5] = 1;
			d[6] = 0;
			d[7] = 0;
			d[8] = 0;
			d[9] = 0;
			d[10] = 1;
			d[11] = 0;
			d[12] = 0;
			d[13] = 0;
			d[14] = 0;
			d[15] = 1;
			return this;
		}
		translate(x, y, z) {
			const d = this.data;
			d[12] = d[0] * x + d[4] * y + d[8] * z + d[12];
			d[13] = d[1] * x + d[5] * y + d[9] * z + d[13];
			d[14] = d[2] * x + d[6] * y + d[10] * z + d[14];
			d[15] = d[3] * x + d[7] * y + d[11] * z + d[15];
			return this;
		}
		rotateX(angle) {
			const d = this.data;
			const s = Math.sin(angle);
			const c = Math.cos(angle);
			const a10 = d[4];
			const a11 = d[5];
			const a12 = d[6];
			const a13 = d[7];
			const a20 = d[8];
			const a21 = d[9];
			const a22 = d[10];
			const a23 = d[11];
			d[4] = a10 * c + a20 * s;
			d[5] = a11 * c + a21 * s;
			d[6] = a12 * c + a22 * s;
			d[7] = a13 * c + a23 * s;
			d[8] = a10 * -s + a20 * c;
			d[9] = a11 * -s + a21 * c;
			d[10] = a12 * -s + a22 * c;
			d[11] = a13 * -s + a23 * c;
			return this;
		}
		rotateY(angle) {
			const d = this.data;
			const s = Math.sin(angle);
			const c = Math.cos(angle);
			const a00 = d[0];
			const a01 = d[1];
			const a02 = d[2];
			const a03 = d[3];
			const a20 = d[8];
			const a21 = d[9];
			const a22 = d[10];
			const a23 = d[11];
			d[0] = a00 * c + a20 * -s;
			d[1] = a01 * c + a21 * -s;
			d[2] = a02 * c + a22 * -s;
			d[3] = a03 * c + a23 * -s;
			d[8] = a00 * s + a20 * c;
			d[9] = a01 * s + a21 * c;
			d[10] = a02 * s + a22 * c;
			d[11] = a03 * s + a23 * c;
			return this;
		}
		perspective(fov, aspect) {
			const d = this.data;
			const near = 0.02;
			const far = 100;
			const top = near * Math.tan(fov * Math.PI / 360);
			const right = top * aspect;
			const left = -right;
			const bottom = -top;
			d[0] = 2 * near / (right - left);
			d[1] = 0;
			d[2] = 0;
			d[3] = 0;
			d[4] = 0;
			d[5] = 2 * near / (top - bottom);
			d[6] = 0;
			d[7] = 0;
			d[8] = (right + left) / (right - left);
			d[9] = (top + bottom) / (top - bottom);
			d[10] = -(far + near) / (far - near);
			d[11] = -1;
			d[12] = 0;
			d[13] = 0;
			d[14] = -(2 * far * near) / (far - near);
			d[15] = 0;
			return this;
		}
		load() {
			gl.uniformMatrix4fv(this.u, gl.FALSE, this.data);
			return this;
		}
	};
	////////////////////////////////////////////////////////////////
	const gl = canvas.init();
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
	const camera = {
		proj: new Mat4(canvas.program, "camProj").load(),
		view: new Mat4(canvas.program, "camView").load()
	};
	canvas.resize();
	window.addEventListener("resize", () => canvas.resize(), false);
	////////////////////////////////////////////////////////////////
	const decodeHeightMap = () => {
		const width = 512;
		const height = 512;
		const img = document.getElementById("heightmap");
		const cmap = document.createElement("canvas");
		cmap.width = width;
		cmap.height = height;
		const cty = cmap.getContext("2d");
		cty.drawImage(img, 0, 0);
		const hmap = cty.getImageData(0, 0, width, height).data;
		const readPixel = (x, y) => hmap[(y * width + x) * 4];
		const freePixel = (x, y) => hmap[(y * width + x) * 4 + 3] !== 0;
		const Rect = class {
			constructor(x, y, w, h) {
				this.x = x;
				this.y = y;
				this.w = w;
				this.h = h;
				this.c = readPixel(x, y);
			}
			draw() {
				for (let x = this.x; x < this.x + this.w; x++) {
					for (let y = this.y; y < this.y + this.h; y++) {
						hmap[(y * width + x) * 4 + 3] = 0;
					}
				}
				if (this.c > 32) iV = concat(vertices, cube(
					(this.x - width * 0.5) * 0.05, 
					(this.y - height * 0.5) * 0.05, 
					this.w * 0.05, 
					this.c * 0.03, 
					this.h * 0.05
				), iV);
			}
			grow() {
				let w = this.w;
				let h = this.h;
				let s = true;
				do {
					w++;
					h++;
					s = this.sameColorV(this.x, this.y, w, h) && this.sameColorH(this.x, this.y, w, h);
				} while (s);
				w--;
				h--;
				const c1 = readPixel(this.x, this.y + h);
				if (this.c === c1 && freePixel(this.x, this.y + h) === true) {
					do {
						h++;
						s = this.sameColorV(this.x, this.y, w, h);
					} while (s);
					h--;
				} else {
					const c1 = readPixel(this.x + w, this.y);
					if (this.c === c1 && freePixel(this.x + w, this.y) === true) {
						do {
							w++;
							s = this.sameColorH(this.x, this.y, w, h);
						} while (s);
						w--;
					}
				}
				this.w = w;
				this.h = h;
			}
			sameColorV(x0, y0, w, h) {
				const c0 = readPixel(x0, y0);
				for (let x = x0; x < x0 + w; x++) {
					const c = readPixel(x, y0 + h - 1);
					if (c !== c0 || freePixel(x, y0 + h - 1) === false) return false;
				}
				return true;
			}
			sameColorH(x0, y0, w, h) {
				const c0 = readPixel(x0, y0);
				for (let y = y0; y < y0 + h; y++) {
					const c = readPixel(x0 + w - 1, y);
					if (c !== c0 || freePixel(x0 + w - 1, y) === false) return false;
				}	
				return true;
			}
		};
		const vertices = new Float32Array(2000000);
		let iV = 0;
		const top = (x, z, l, h, w) => [x,h,z,0,1,0,x,h,z+w,0,1,0,x+l,h,z+w,0,1,0,x,h,z,0,1,0,x+l,h,z+w,0,1,0,x+l,h,z,0,1,0];
		const cube = (x, z, l, h, w) => [
			x,h,z,0,1,0,x,h,z+w,0,1,0,x+l,h,z+w,0,1,0,x,h,z,0,1,0,x+l,h,z+w,0,1,0,x+l,h,z,0,1,0,
			x,0,z,-1,0,0,x,0,z+w,-1,0,0,x,h,z+w,-1,0,0,x,0,z,-1,0,0,x,h,z+w,-1,0,0,x,h,z,-1,0,0,
			x+l,0,z,1,0,0,x+l,h,z,1,0,0,x+l,h,z+w,1,0,0,x+l,0,z,1,0,0,x+l,h,z+w,1,0,0,x+l,0,z+w,1,0,0,
			x,0,z,0,0,-1,x,h,z,0,0,-1,x+l,h,z,0,0,-1,x,0,z,0,0,-1,x+l,h,z,0,0,-1,x+l,0,z,0,0,-1,
			x,0,z+w,0,0,1,x+l,0,z+w,0,0,1,x+l,h,z+w,0,0,1,x,0,z+w,0,0,1,x+l,h,z+w,0,0,1,x,h,z+w,0,0,1
		];
		const attribute = (program, name, data, size, stride, offset) => {
			if (data !== null) {
				const buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
			}
			const index = gl.getAttribLocation(program, name);
			gl.enableVertexAttribArray(index);
			gl.vertexAttribPointer(index, size, gl.FLOAT, false, stride, offset);
		};
		const concat = (a1, a2, index) => {
			for (let i = 0, l = a2.length; i < l; i++) {
				a1[index++] = a2[i];
			}
			return index;
		};
		const heap = [[0,0]];
		do {
			const c = heap.shift();
			if (freePixel(c[0], c[1]) === true) {
				const r = new Rect(c[0], c[1], 1, 1);
				r.grow();
				r.draw();
				if (r.y + r.h < height && freePixel(r.x, r.y + r.h) === true) heap.push([r.x, r.y + r.h]);
				if (r.x + r.w < width && freePixel(r.x + r.w, r.y) === true) heap.push([r.x + r.w, r.y]);
			}
		} while (heap.length);
		iV = concat(vertices, top(-width * 1, -height * 0.05, width * 2, 0, height * 0.1), iV);
		attribute(canvas.program, "aPosition", vertices, 3, 24, 0);
		attribute(canvas.program, "aNormal", null, 3, 24, 12);
		return iV / 6;
	}
	let numElements = decodeHeightMap();
	////////////////////////////////////////////////////////////////
	let ry = 51.2, time = 0, dt = 0.0009;
	let rx = 0.5 * Math.PI * Math.floor(Math.random() * 4);
	const run = (newTime) => {
		requestAnimationFrame(run);
		let d = 0.001 * (newTime - time);
		if (d > 0.1) d = 0.1;
		dt += (d - dt) * 0.01;
		time = newTime;
		gl.clearColor(1, 1, 1, 0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		ry += dt;
		camera.view
			.identity()
			.rotateX(0.8)
			.translate(0, -8, -10 + ry % 25.6)
			.rotateY(rx)
			.load();
		gl.drawArrays(gl.TRIANGLES, 0, numElements);
		camera.view
			.identity()
			.rotateX(0.8)
			.translate(0, -8, -10 - 25.6 + ry % 25.6)
			.rotateY(rx)
			.load();
		gl.drawArrays(gl.TRIANGLES, 0, numElements);
	};
	requestAnimationFrame(run);
	["click", "touchdown"].forEach(event => {
		document.addEventListener(event, () => rx += Math.PI * 0.5, false);
	});
}
      //# sourceURL=pen.js
    </script>



    <script style="display: none !important;">
  (function() {
    var __animationDuration = 4000;

    setTimeout(function() {
      // If onload hasn't been called, stop all requests after 2 seconds
      if (typeof(_l) == "undefined") {
        if (window.stop !== undefined) window.stop();
        else if (document.execCommand !== undefined) document.execCommand("Stop", false);
      }
    }, 2000, "push");

    /*
    * Capture and kill CSS animations after X number of seconds
    */
    function pauseAnimations() {
      var body = document.getElementsByTagName("body")[0];

      if (body.addEventListener) {
        body.addEventListener("webkitAnimationStart", listener, false);
        body.addEventListener("webkitAnimationIteration", listener, false);
        body.addEventListener("animationstart", listener, false);
        body.addEventListener("animationiteration", listener, false);
      }
    }

    function listener(e) {

      var targetEl;

      if (e.type == "webkitAnimationStart" || e.type == "webkitAnimationIteration") {

        targetEl = e.target;

        setTimeout(function() {
          targetEl.style.webkitAnimationPlayState = "paused";
        }, __animationDuration, "push");

      } else if (e.type == "animationstart" || e.type == "animationiteration") {

        targetEl = e.target;

        setTimeout(function() {
          targetEl.style.MozAnimationPlayState = "paused";
        }, __animationDuration, 'push');

      }
    }

    pauseAnimations();

    // Pause all audio elements, allow the audio/video
    // elements to render before stopping them
    function pauseElementTypes(type) {
      for (var i = 0, els = document.getElementsByTagName(type); i < els.length; i++) {
        els[i].pause();
      }
    }

    // Wait until the elements have been created to pause them
    setTimeout(function() {
      pauseElementTypes("audio");
      pauseElementTypes("video");
    }, 100);

  }());
  </script>

  

  <script src="https://static.codepen.io/assets/editor/live/css_reload-5619dc0905a68b2e6298901de54f73cefe4e079f65a75406858d92924b4938bf.js"></script>
</body>

</html>
 

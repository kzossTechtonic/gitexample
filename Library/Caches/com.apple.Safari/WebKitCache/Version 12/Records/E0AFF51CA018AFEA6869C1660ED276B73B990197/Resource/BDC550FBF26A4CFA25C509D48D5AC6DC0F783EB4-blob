
<!DOCTYPE html>
<html lang="en" >

<head>

  <meta charset="UTF-8">
  <link rel="shortcut icon" type="image/x-icon" href="https://static.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico" />
  <link rel="mask-icon" type="" href="https://static.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111" />
  <title>CodePen - Stretchy Baby</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">

  <style>
:root {
    --sb-black: #19191B;
    --sb-grey: #82828A;
    --sb-white: #FFFFFF;
    --sb-cream: #F5E7E6;
    --sb-green: #45D5BE;
    --sb-blue: #0EBAE7;
    --sb-lightblue: #B7F2FF;
    --sb-yellow: #FF9A01;
    --sb-brown: #BC4117;
    --sb-tan: #FEB096;
    --sb-red: #FC0001;
    --sb-pink: #FEB2D2;
}

@font-face {
    font-family: 'AZVintageTattoo';
    font-style: normal;
    font-weight: normal;
    src: url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/59639/azvintat-webfont.woff2') format('woff2'),
         url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/59639/azvintat-webfont.woff') format('woff');
}

html {
    height: 100%;
}

body {
    background: var(--sb-white);
    color: var(--sb-black);
    font-family: 'AZVintageTattoo', sans-serif;
    font-size: 3vw;
    font-weight: 900;
    letter-spacing: 0.05em;
    min-height: 100%;
    text-align: center;
    text-transform: uppercase;
}
</style>

      <style>
      html,
body {
    height: 100%;
}

.title {
    color: var(--sb-white);
    left: 50%;
    line-height: 1.3;
    pointer-events: none;
    position: absolute;
    text-shadow: 0 0 10px var(--sb-black);
    top: 50%;
    -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
    transition: opacity 0.3s ease-out;
}
.title[data-hide="true"] {
    opacity: 0;
}

.toggle {
    bottom: 30px;
    font-size: 16px;
    left: 30px;
    position: absolute;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
            user-select: none;
}
.toggle-on,
.toggle-off {
    cursor: pointer;
    display: inline-block;
    opacity: 0.3;
    padding: 5px;
    transition: opacity 0.2s ease-out;
    vertical-align: middle;
}
.toggle-on[data-active="true"],
.toggle-off[data-active="true"] {
    opacity: 1;
}

.canvas {
    -webkit-animation: bob 0.3s ease-in-out 0s infinite alternate;
            animation: bob 0.3s ease-in-out 0s infinite alternate;
    cursor: -webkit-grab;
    cursor: grab;
    display: block;
}
.canvas:active {
    cursor: -webkit-grabbing;
    cursor: grabbing;
}

@-webkit-keyframes bob {
    0% { -webkit-transform: translate3d(0, -1%, 0); transform: translate3d(0, -1%, 0); }
    100% { -webkit-transform: translate3d(0, 1%, 0); transform: translate3d(0, 1%, 0); }
}

@keyframes bob {
    0% { -webkit-transform: translate3d(0, -1%, 0); transform: translate3d(0, -1%, 0); }
    100% { -webkit-transform: translate3d(0, 1%, 0); transform: translate3d(0, 1%, 0); }
}
    </style>

  <script>
  window.console = window.console || function(t) {};
  window.open = function(){ console.log("window.open is disabled."); };
  window.print   = function(){ console.log("window.print is disabled."); };
  window.alert   = function(){ console.log("window.alert is disabled."); };
  window.confirm = function(){ console.log("window.confirm is disabled."); };
  window.prompt  = function(){ console.log("window.prompt is disabled."); };
  window.Notification = function() { console.log("HTML5 notifications are disabled."); };
</script>

  
    <script>
    (function() {
      /*
      * Capture all errors for this pen
      **/
      window.onerror = function(/* message, file, line */) {
        return true;
      };

      /*
      * Capture and kill Web Audio and Speech
      */
      if (typeof (AudioContext) != "undefined" || typeof (webkitAudioContext) != "undefined") {
        AudioContext = function() {
          return false;
        };

        webkitAudioContext = function() {
          return false;
        };
      }

      if (typeof (mozAudioContext) != "undefined") {
        mozAudioContext = function() {
          return false;
        };
      }

      if ("speechSynthesis" in window) {
        window.speechSynthesis = {};
      }
      if ("speak" in speechSynthesis) {
        speechSynthesis.speak = function() {
          return false;
        };
      }

      // Kill the browser asking for access to the video cam or audio
      navigator.getUserMedia = function() {
      };
      navigator.mozGetUserMedia = function() {
      };
      navigator.webkitGetUserMedia = function() {
      };
      navigator.mediaDevices.getUserMedia = function() {
      };

      
      /**
      * Capture and kill animations after X number of seconds
      **/
      var __animationDuration = 4000;
      var __animationsTimedOut = false;
      var __animationRequests = [];
      var __requestAnimationFrame = false;
      var __cancelAnimationFrame = false;
      var x, i;

      var vendorsReqestAnimationFrame = [
        "requestAnimationFrame",
        "mozRequestAnimationFrame",
        "webkitRequestAnimationFrame"
      ];

      // find the browsers requestAnimationFrame and cancelAnimationFrame
      for (x = 0; x < vendorsReqestAnimationFrame.length; x++) {
        if (!__requestAnimationFrame) {
          __requestAnimationFrame = window[vendorsReqestAnimationFrame[x]
          ];
        }
      }

      __cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

      // Wrap the requestAnimationFrame so we can stop it in the future
      function __reqFrame(callback, element) {
        // after the timeout we no longer take requests
        var timerID;
        if (__animationsTimedOut) {
          return 0;
        } else {
          timerID = __requestAnimationFrame(callback, element);
          __animationRequests.push(timerID);

          return timerID;
        }
      }

      for (x = 0; x < vendorsReqestAnimationFrame.length; x++) {
        window[vendorsReqestAnimationFrame[x]] = __reqFrame;
      }

      // Cancel the animations after expiration
      setTimeout(function() {
        for (i = 0; i < __animationRequests.length; i++) {
          __cancelAnimationFrame(__animationRequests[i]);
        }

        var ss = window.document.createElement("style");
        ss.textContent = "*, *::before, *::after { animation-play-state: paused !important; }";
        var ref = window.document.getElementsByTagName("script")[0];
        ref.parentNode.insertBefore(ss, ref);

        __animationsTimedOut = true;
      }, __animationDuration, "push");

      /**
      * Capture setInterval and setTimeout to kill after X number of seconds
      **/
      window.setInterval = (function(oldSetInterval) {
        var registered = [];

        function f(a,b) {
          // check if the time has expired,
          // after __animationDuration expires don't take anymore setIntervals
          if (this.timedOut) {
            return 0;
          } else {
            return registered[ registered.length ] = oldSetInterval(a,b);
          }
        }

        f.clearAll = function() {
          var r;

          while (r = registered.pop()) {
            clearInterval( r );
          }

          this.timedOut = true;
        };

        f.timedOut = false;

        return f;
      }(window.setInterval));

      window.setTimeout = (function(oldSetTimeout) {
        var registered = [];

        // because some of our timeouts may time out afterwards
        // we want to make sure they know the secret sauce to still use
        // setTimeout after the time has expired, thats why we have a
        // third param
        function f(a, b, push) {
          // check if the time has expired,
          // after __animationDuration expires don't take anymore requests
          if (this.timedOut && typeof(push) == "undefined") {
            return 0;
          } else {
            // If push is there, never clear that interval
            // so never add it to the registry
            if (push) {
              return oldSetTimeout(a,b);
            } else {
              return registered[ registered.length ] = oldSetTimeout(a,b);
            }
          }
        }

        f.clearAll = function() {
          var r;

          while (r = registered.pop()) {
            clearTimeout( r );
          }

          this.timedOut = true;
        };

        f.timedOut = false;

        return f;
      }(window.setTimeout));

      setTimeout(function() {

        setTimeout.clearAll();
        setInterval.clearAll();

        // Stop Web Animations API
        // Idea from Gregor: https://github.com/CodePen/CodePen-Bug-Reporting-Only/issues/173#issuecomment-203443301
        // Status as of August 2016:
        //  Chrome = stops animations
        //  Safari = doesn't support anyway
        //  Firefox = doesn't stop them, but probably will someday? Doesn't error
        if (document.timeline && typeof document.timeline.getAnimations === "function") {
          document.timeline.getAnimations().map(function(animation) {
            animation.pause();
          });
        }
    
      }, __animationDuration, "push");

    }());
  </script>

  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>


</head>

<body translate="no"  onload="_l='t';">

  <canvas class="canvas"></canvas>
<h1 class="title">Drag the baby</h1>
<div class="toggle">
    Frankenbaby Mode: <div class="toggle-on">On</div>/<div class="toggle-off" data-active="true">Off</div>
</div>
    <script src="//static.codepen.io/assets/common/stopExecutionOnTimeout-de7e2ef6bfefd24b79a3f68b414b87b8db5b08439cac3f1012092b2290c719cd.js"></script>

  <script>
window.COLORS = {
    white: window.getComputedStyle(document.body).getPropertyValue('--sb-white').trim(),
    lightGrey: window.getComputedStyle(document.body).getPropertyValue('--sb-lightgrey').trim(),
    grey: window.getComputedStyle(document.body).getPropertyValue('--sb-grey').trim(),
    darkGrey: window.getComputedStyle(document.body).getPropertyValue('--sb-darkgrey').trim(),
    black: window.getComputedStyle(document.body).getPropertyValue('--sb-black').trim(),
    red: window.getComputedStyle(document.body).getPropertyValue('--sb-red').trim(),
    green: window.getComputedStyle(document.body).getPropertyValue('--sb-green').trim(),
    brown: window.getComputedStyle(document.body).getPropertyValue('--sb-brown').trim(),
    yellow: window.getComputedStyle(document.body).getPropertyValue('--sb-yellow').trim(),
    tan: window.getComputedStyle(document.body).getPropertyValue('--sb-tan').trim(),
    lightBlue: window.getComputedStyle(document.body).getPropertyValue('--sb-lightblue').trim(),
    blue: window.getComputedStyle(document.body).getPropertyValue('--sb-blue').trim(),
}

</script>

  

    <script >
      var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;}; // this code may be great,
// it may be trash, i don't know
// i'm no scientist
//
// - a haiku by jonny
var SEGMENT_SIZE = 50; // size of a segment in the grid
var DRAG_RADIUS = SEGMENT_SIZE * 5; // radius of dragging pixels around mouse
var SNAP_BACK_DURATION = 1000; // snap back speed
var FRICTION = 0.5; // stretch friction
var WIREFRAME_MODE = false; // neked bones mode
var SPRITE_SPEED = 20; // sprite animation speed (based on 60fps)

var toggleOn = document.querySelector('.toggle-on');
var toggleOff = document.querySelector('.toggle-off');
var title = document.querySelector('.title');
var canvas = document.querySelector('.canvas');
var context = canvas.getContext('2d');
var bufferCanvas = document.createElement('canvas');
var bufferContext = bufferCanvas.getContext('2d');
var img = document.createElement('img');

var babyFrame = 0; // the current frame of the sprite animation
var gridSize = 0; // size of the grid
var points = []; // an array of all the draggable points
var segments = []; // an array of each square in the grid
var time = Date.now(); // the current draw time (set in our draw method)
var dragStart = { x: 0, y: 0 // the drag start point 
};var dragPoints = []; // an array of any current dragging points
var isDragging = false;
var isFrankenBabyMode = false; // this is controlled by the toggle at the bottom of the page

// get the distance between two points
var getDistance = function getDistance(_ref, _ref2) {var x1 = _ref.x,y1 = _ref.y;var x2 = _ref2.x,y2 = _ref2.y;return (
        Math.hypot(x2 - x1, y2 - y1));};

// easey-breezy
var easeOutElastic = function easeOutElastic(t) {return .04 * t / --t * Math.sin(25 * t);};

// throttle function
var throttle = function throttle(func, limit) {
    var inThrottle = void 0;
    return function () {
        var args = arguments;
        var context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(function () {return inThrottle = false;}, limit);
        }
    };
};

// get linear soluuush
var getLinearSolution = function getLinearSolution(r1, s1, t1, r2, s2, t2, r3, s3, t3) {
    r1 = parseFloat(r1);
    s1 = parseFloat(s1);
    t1 = parseFloat(t1);
    r2 = parseFloat(r2);
    s2 = parseFloat(s2);
    t2 = parseFloat(t2);
    r3 = parseFloat(r3);
    s3 = parseFloat(s3);
    t3 = parseFloat(t3);

    var a = ((t2 - t3) * (s1 - s2) - (t1 - t2) * (s2 - s3)) / ((r2 - r3) * (s1 - s2) - (r1 - r2) * (s2 - s3));
    var b = ((t2 - t3) * (r1 - r2) - (t1 - t2) * (r2 - r3)) / ((s2 - s3) * (r1 - r2) - (s1 - s2) * (r2 - r3));
    var c = t1 - r1 * a - s1 * b;

    return [a, b, c];
};

// create an array of points and an array 
// of segments with point references
var createPoints = function createPoints() {
    var size = Math.min(window.innerWidth, window.innerHeight);
    var segmentCount = Math.min(10, Math.floor(size / SEGMENT_SIZE));
    var totalSize = SEGMENT_SIZE * segmentCount;
    var midSize = totalSize / 2;
    var pointCount = segmentCount + 1;
    var pointTotal = pointCount * pointCount;
    var segmentTotal = segmentCount * segmentCount;
    var offsetX = window.innerWidth / 2 - midSize;
    var offsetY = window.innerHeight / 2 - midSize;

    gridSize = totalSize;

    // set title font size to overlay our baby nicely
    title.style.fontSize = gridSize * 0.12 + 'px';
    title.style.width = gridSize + 'px';

    // create the array of vertices
    for (var i = 0; i < pointTotal; i++) {
        var x = i % pointCount * SEGMENT_SIZE;
        var y = Math.floor(i / pointCount) * SEGMENT_SIZE;
        points.push({
            x: offsetX + x, // x position (account for the canvas offset since we're centering)
            y: offsetY + y, // y position (account for the canvas offset since we're centering)
            dragX: 0, // the point's drag x (this is used to offset the point when dragging)
            dragY: 0, // the point's drag y (this is used to offset the point when dragging)
            letGoTime: 0, // the time the point was let go (this is set in our mouseup handler)
            isDragging: false // indicator if the current point is dragging or not (we don't want to start stretching it back if we're still dragging)
        });
    }

    // create an array of segments
    // there is probably a MUCH more efficient way to 
    // do this, but whatever... it's supposed to be fun
    for (var s = 0; s < segmentTotal; s++) {
        var offset = Math.floor(s / segmentCount); // offset indicating which row we're on
        var tl = s + offset; // top left point of this square
        var tr = s + offset + 1; // top right point of this square
        var bl = s + offset + pointCount; // bottom left point of this square
        var br = s + offset + pointCount + 1; // bottom right point of this square

        // segments is an array of references to indexes in our points array
        // I did this so that when a point is moved, any segment that contains 
        // that point automatically accounts for that.
        segments.push([tl, tr, bl, br]);
    }
};

// draw the grid
var draw = function draw() {
    time = Date.now(); // set the current draw time

    // resize the canvas to fill the screen
    // (doing this also clears the canvas)
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    context.strokeStyle = '#f00';

    // draw our image into a buffer canvas
    // this is needed in order to scale the image to our grid size.
    bufferCanvas.width = canvas.width * 2;
    bufferCanvas.height = canvas.height;
    bufferContext.drawImage(img, (canvas.width - gridSize) / 2, (canvas.height - gridSize) / 2, gridSize * 2, gridSize * 1.15);

    // loop through our segments and draw each one
    for (var i = 0; i < segments.length; i++) {
        // get references to each of our segment's corner points 
        var segment = segments[i];
        var spriteFrame = Math.round(babyFrame / SPRITE_SPEED);var _points$segment$ =
        points[segment[0]],x1 = _points$segment$.x,y1 = _points$segment$.y,dragX1 = _points$segment$.dragX,dragY1 = _points$segment$.dragY;var _points$segment$2 =
        points[segment[1]],x2 = _points$segment$2.x,y2 = _points$segment$2.y,dragX2 = _points$segment$2.dragX,dragY2 = _points$segment$2.dragY;var _points$segment$3 =
        points[segment[2]],x3 = _points$segment$3.x,y3 = _points$segment$3.y,dragX3 = _points$segment$3.dragX,dragY3 = _points$segment$3.dragY;var _points$segment$4 =
        points[segment[3]],x4 = _points$segment$4.x,y4 = _points$segment$4.y,dragX4 = _points$segment$4.dragX,dragY4 = _points$segment$4.dragY;

        // get the data needed to create our transformation matrix
        var xm = getLinearSolution(0, 0, x1 + dragX1, SEGMENT_SIZE, 0, x2 + dragX2, 0, SEGMENT_SIZE, x3 + dragX3);
        var ym = getLinearSolution(0, 0, y1 + dragY1, SEGMENT_SIZE, 0, y2 + dragY2, 0, SEGMENT_SIZE, y3 + dragY3);
        var xn = getLinearSolution(SEGMENT_SIZE, SEGMENT_SIZE, x4 + dragX4, SEGMENT_SIZE, 0, x2 + dragX2, 0, SEGMENT_SIZE, x3 + dragX3);
        var yn = getLinearSolution(SEGMENT_SIZE, SEGMENT_SIZE, y4 + dragY4, SEGMENT_SIZE, 0, y2 + dragY2, 0, SEGMENT_SIZE, y3 + dragY3);

        // draw the first of our triangles
        // triangles are needed in order to properly skew our segments
        context.save();
        context.setTransform(xm[0], ym[0], xm[1], ym[1], xm[2], ym[2]);
        context.beginPath();
        context.moveTo(-1, -1);
        context.lineTo(SEGMENT_SIZE + 1, -1);
        context.lineTo(-1, SEGMENT_SIZE + 1);
        context.lineTo(-1, -1);
        context.closePath();
        context.clip();

        // if wireframe mode is on, add a stroke around the triangle. 
        // otherwise, draw our image into it
        if (WIREFRAME_MODE) {
            context.stroke();
        } else {
            context.drawImage(bufferCanvas, x1 + gridSize * spriteFrame, y1, SEGMENT_SIZE, SEGMENT_SIZE, -1, -1, SEGMENT_SIZE + 2, SEGMENT_SIZE + 2);
        }
        context.restore();

        // do the same thing for our other triangle to complete our segment square
        context.save();
        context.setTransform(xn[0], yn[0], xn[1], yn[1], xn[2], yn[2]);
        context.beginPath();
        context.moveTo(SEGMENT_SIZE, SEGMENT_SIZE);
        context.lineTo(SEGMENT_SIZE, 0);
        context.lineTo(SEGMENT_SIZE - 1, 0);
        context.lineTo(-1, SEGMENT_SIZE);
        context.lineTo(0, SEGMENT_SIZE);
        context.lineTo(SEGMENT_SIZE, SEGMENT_SIZE);
        context.closePath();
        context.clip();
        if (WIREFRAME_MODE) {
            context.stroke();
        } else {
            context.drawImage(bufferCanvas, x1 + gridSize * spriteFrame, y1, SEGMENT_SIZE, SEGMENT_SIZE, -1, -1, SEGMENT_SIZE + 2, SEGMENT_SIZE + 2);
        }
        context.restore();
    }

    // loop through our points and check which ones, if any, were dragged. 
    // if a point was dragged, we want to start stretching it back into place.
    if (!isFrankenBabyMode) {
        points.forEach(function (point) {var
            dragX = point.dragX,dragY = point.dragY,isDragging = point.isDragging,letGoDragX = point.letGoDragX,letGoDragY = point.letGoDragY,letGoTime = point.letGoTime;
            if (!isDragging && letGoTime) {
                var transitionTime = time - letGoTime; // the time that has elapsed, in milliseconds, since our point was let go (or stopped dragging)
                var progress = easeOutElastic(1 - transitionTime / SNAP_BACK_DURATION); // the progress, 0 - 1, of our animation. this is based off our constant SNAP_BACK_DURATION

                // start snapping our point back based on the animation progress
                point.dragX = letGoDragX * progress;
                point.dragY = letGoDragY * progress;

                // if our SNAP_BACK_DURATION time has expired, 
                // reset the point's dragging data
                if (transitionTime > SNAP_BACK_DURATION) {
                    point.letGoTime = 0;
                    point.dragX = 0;
                    point.dragY = 0;
                }
            }
        });
    }

    // increment baby frame counter
    babyFrame++;
    if (babyFrame > SPRITE_SPEED) {
        babyFrame = 0;
    }

    // draw it all over again! 
    // using requestAnimationFrame vs a setInterval has a lot of benefits. 
    // requestAnimationFrame lets the browser decide when it's best to 
    // to draw which results in good performance. requestAnimationFrame 
    // also helps slow down/stop the animation loop when the browser tab 
    // is no longer in focus.
    window.requestAnimationFrame(draw);
};

// mousedown/touchstart event handler
var onDragStart = function onDragStart(e) {
    e.preventDefault();var _ref3 =

    e.touches ? e.touches[0] : e,pageX = _ref3.pageX,pageY = _ref3.pageY; // normalize mouse and touch events
    dragStart = { x: pageX, y: pageY // set the drag start point
    };dragPoints = []; // clear any previous dragPoints

    // loop through our points and find the distance between it and our 
    // start point. if the distance is within our DRAG_RADIUS, we should 
    // start dragging it when the mouse moves.
    points.forEach(function (point, i) {var
        x = point.x,y = point.y,dragX = point.dragX,dragY = point.dragY;
        var draggedPoint = { x: x + dragX, y: y + dragY // making sure we account for the distance this point has already dragged, in case it hasn't fully snapped back yet.
        };var distance = getDistance(dragStart, draggedPoint); // get the distance between the point and our start point
        if (Math.abs(distance) <= DRAG_RADIUS) {
            point.isDragging = true; // the point was in our radius, so set that it's dragging
            dragPoints.push({
                index: i, // store a reference to the point's index
                strength: 1 - distance / DRAG_RADIUS, // strength indicates how far the point was from our drag start point. this is what makes the further away points move slower than the ones close to the mouse
                baseDragX: dragX, // set the base drag x to be used when we move the mouse
                baseDragY: dragY // set the base drag y to be used when we move the mouse
            });
        }
    });

    // set the global isDragging boolean 
    // this is used to prevent our mousemove handler 
    // from doing anything unless we're actually dragging.
    isDragging = true;
};

// mousemove/touchmove event handler
var onDrag = throttle(function (e) {
    e.preventDefault();

    if (!isDragging) return; // don't do anything if we aren't dragging

    // hide the title since the user knows they can drag now
    if (dragPoints.length > 0) {
        title.dataset.hide = true;
    }var _ref4 =

    e.touches ? e.touches[0] : e,pageX = _ref4.pageX,pageY = _ref4.pageY; // normalize mouse and touch events
    var _dragStart = dragStart,startX = _dragStart.x,startY = _dragStart.y; // get our drag start point
    var diffX = (pageX - startX) * FRICTION; // get how far we've moved the mouse on the x
    var diffY = (pageY - startY) * FRICTION; // get how far we've moved the mouse on the y
    dragPoints.forEach(function (_ref5) {var index = _ref5.index,strength = _ref5.strength,baseDragX = _ref5.baseDragX,baseDragY = _ref5.baseDragY;
        points[index].dragX = baseDragX + diffX * strength; // set the dragX on the point to how far we moved on the x, making sure to account for the point's distance from our start (or "strength")
        points[index].dragY = baseDragY + diffY * strength; // set the dragY on the point to how far we moved on the y, making sure to account for the point's distance from our start (or "strength")
    });
}, 20);

// mouseup/touchend event handler
var onDragEnd = function onDragEnd(e) {
    e.preventDefault();

    isDragging = false; // reset the global isDragging boolean

    // loop through our points and check for our dragging points
    points.forEach(function (point, i) {
        // if the point was being dragged, set data needed for 
        // the snap back animation
        if (point.isDragging) {
            points[i] = _extends({},
            point, {
                letGoDragX: point.dragX, // the dragX at the time the point was let go
                letGoDragY: point.dragY, // the dragY at the time the point was let go
                letGoTime: Date.now(), // the time the point was let go
                isDragging: false // reset the isDragging boolean since we are no longer dragging this point
            });
        }
    });
};

var onToggleFrankenbabyOn = function onToggleFrankenbabyOn() {
    toggleOn.dataset.active = true; // set on toggle to active
    toggleOff.dataset.active = false; // set off toggle to inactive
    isFrankenBabyMode = true; // turn on frankenbaby mode
};

var onToggleFrankenbabyOff = function onToggleFrankenbabyOff() {
    toggleOn.dataset.active = false; // set on toggle to inactive
    toggleOff.dataset.active = true; // set off toggle to active
    isFrankenBabyMode = false; // turn off frankenbaby mode
};

// resize event handler
window.addEventListener('resize', function () {
    // there are a lot of calculations happening that are 
    // based on the window size. its much easier to just reset 
    // everything here when we resize instead of updating all 
    // our points.
    points = [];
    segments = [];
    createPoints();
});


// toggle events
toggleOn.addEventListener('click', onToggleFrankenbabyOn);
toggleOff.addEventListener('click', onToggleFrankenbabyOff);
toggleOn.addEventListener('touchstart', onToggleFrankenbabyOn);
toggleOff.addEventListener('touchstart', onToggleFrankenbabyOff);

// drag events
document.addEventListener('mousedown', onDragStart);
document.addEventListener('mousemove', onDrag);
document.addEventListener('mouseup', onDragEnd);
document.addEventListener('touchstart', onDragStart, { passive: false });
document.addEventListener('touchmove', onDrag, { passive: false });
document.addEventListener('touchend', onDragEnd, { passive: false });

// please don't steal my artwork. 
// I work very hard on it!
img.src = 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/59639/cry-baby.jpg?666';

createPoints(); // create our array of points and segments
draw(); // start the draw loop
      //# sourceURL=pen.js
    </script>



    <script style="display: none !important;">
  (function() {
    var __animationDuration = 4000;

    setTimeout(function() {
      // If onload hasn't been called, stop all requests after 2 seconds
      if (typeof(_l) == "undefined") {
        if (window.stop !== undefined) window.stop();
        else if (document.execCommand !== undefined) document.execCommand("Stop", false);
      }
    }, 2000, "push");

    /*
    * Capture and kill CSS animations after X number of seconds
    */
    function pauseAnimations() {
      var body = document.getElementsByTagName("body")[0];

      if (body.addEventListener) {
        body.addEventListener("webkitAnimationStart", listener, false);
        body.addEventListener("webkitAnimationIteration", listener, false);
        body.addEventListener("animationstart", listener, false);
        body.addEventListener("animationiteration", listener, false);
      }
    }

    function listener(e) {

      var targetEl;

      if (e.type == "webkitAnimationStart" || e.type == "webkitAnimationIteration") {

        targetEl = e.target;

        setTimeout(function() {
          targetEl.style.webkitAnimationPlayState = "paused";
        }, __animationDuration, "push");

      } else if (e.type == "animationstart" || e.type == "animationiteration") {

        targetEl = e.target;

        setTimeout(function() {
          targetEl.style.MozAnimationPlayState = "paused";
        }, __animationDuration, 'push');

      }
    }

    pauseAnimations();

    // Pause all audio elements, allow the audio/video
    // elements to render before stopping them
    function pauseElementTypes(type) {
      for (var i = 0, els = document.getElementsByTagName(type); i < els.length; i++) {
        els[i].pause();
      }
    }

    // Wait until the elements have been created to pause them
    setTimeout(function() {
      pauseElementTypes("audio");
      pauseElementTypes("video");
    }, 100);

  }());
  </script>

  

  <script src="https://static.codepen.io/assets/editor/live/css_reload-5619dc0905a68b2e6298901de54f73cefe4e079f65a75406858d92924b4938bf.js"></script>
</body>

</html>
 
